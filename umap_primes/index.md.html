<meta charset="utf-8">
<!-- Markdeep: -->

.<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>


# What do numbers look like?
![One million integers embedded into 2D space with UMAP](primes_umap_1e6_contrast_enhanced.png)

This is the first million integers, represented as binary vectors indicating their prime factors, and laid out using the [UMAP dimensionality reduction algorithm](https://github.com/lmcinnes/umap) by Leland Mcinnes. 
Each integer is represented in a high-dimensional space, and gets squished down to 2D so that numbers with similar prime factorisations are closer
together than those with dissimilar factorisations.

A very pretty structure emerges; this might be spurious in that it captures
more about the layout algorithm than any *"true"* structure of numbers. However, the visual effect is very appealling and requires no tricky manipulation to create.

[Large 4k version of the image suitable for backgrounds](primes_umap_1e6_4k.png)

## Representation
Each integer is represented
as a vector, one element for each possible prime factor, where 0=prime factor not present, 1=prime factor present. This provides a simple geometry for the
integers, where each number can be seen as being composed of prime basis vectors.

These high-dimensional vectors are then squashed down
from thousands of dimensions for each number to just two dimensions, and a point plotted at that coordinate. The points are coloured according to 
the original integer index; brighter colours correspond to larger numbers. The points are laid out so that numbers with similar "angles" to each other are close together. For example, all primes are at 90 degrees to each other, and all powers of a number are identical to each other (0 degree angle).


### Algorithm
* for each `i` up to `n`
    * find prime factors of `i`. 
    * For each `i`, make binary vector with [`π(n)`](https://en.wikipedia.org/wiki/Prime-counting_function) columns (π(n) = number of primes less than `n`), where each element has `1`=prime factor present, `0`=absent. 
* Stack all vectors into a large, sparse matrix 
    
* Lay out with UMAP, using the cosine distance function (dot product).

I used [`li(n)`](https://en.wikipedia.org/wiki/Logarithmic_integral_function) as a cheap upper bound on `π(n)` to estimate the number of columns needed.

For example, for `n=11`, the matrix looks like:
```

             2  3  5  7  11       
            [0. 0. 0. 0. 0.] 0
            [0. 0. 0. 0. 0.] 1
            [1. 0. 0. 0. 0.] 2
            [0. 1. 0. 0. 0.] 3
            [1. 0. 0. 0. 0.] 4
            [0. 0. 1. 0. 0.] 5
            [1. 1. 0. 0. 0.] 6
            [0. 0. 0. 1. 0.] 7
            [1. 0. 0. 0. 0.] 8
            [0. 1. 0. 0. 0.] 9
            [1. 0. 1. 0. 0.] 10
            [0. 0. 0. 0. 1.] 11

```

The image above is reduced from a 1000000x78628 (!) binary matrix to 1000000x2.  This only works because of the excellent sparse matrix support in UMAP.

### Code

The [python code is available](https://gist.github.com/johnhw/dfc7b8b8519aac530ac97da226c17bd5).

[Massive ~10k resolution version [16Mb]](primes_umap_1e6_16k_tight_crop.png)